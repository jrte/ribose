<html>
<body>
<br>
Jrte is about inversion of control for high-volume text analysis and information extraction and 
transformation. An input source presents as a generator of sequences of ordinal numbers. If those 
sequences have a coherent pattern that can be described in terms of catenation, union and repetition
then that description determines a unique regular set. This input pattern description can then be 
extended to interleave at each input ordinal a sequence of output ordinals, which Jrte associates
with effector methods expressed by a target class bound to the transduction. This input/output 
pattern description is compiled by ginr to build a state-minimized finite state automaton (DFA). 
<p>
The Jrte compiler performs a transition-minimizing transformation on automata compiled by ginr to build 
transducers that it packages in a gearbox library for runtime use. The Jrte runtime loads
transducers on demand and provides a simple interface for running and controlling transduction 
processes. Each transduction process has a transducer stack, so running transducers can call each other
(and themselves, recursively), and an input stack, so called transducers can return information to 
callers. Jrte extends the set of input ordinals with a small (extensible) set of signal ordinals 
that are never generated by the source and can be used as unambiguous return codes. 
<p>
Each gearbox is bound to a class instance of {@link com.characterforming.jrte.ITarget} when it
is built. This target class interprets the output ordinals generated by the gearbox transducers, 
expressing an {@link com.characterforming.jrte.IEffector} instance for each output ordinal. The default
transduction target provides named values and effectors paste, cut, copy and clear for extracting
information into values and an out effector to format values for writing onto standard output.
These are probably sufficient for most sed/awk types of transductions, but specialized ITarget 
implementation classes can extend this with additional, domain-specific, effectors as required.  
<p>
At each invokation an effector receives a copy of the current input ordinal (effectors may also 
present a closure-like form that is bound to a single parameter ordinal) and performs some action 
against the target. Over the course of the transduction the input transforms the target by 
calling its effectors in the sequence determined by the transducer transition function. 
<p>
For example, a pattern P describing all 7-bit ASCII text files ending with a newline:
<p>
<pre class="code">P = ((ASCII - nl)<b>*</b> nl)<b>*</b>;</pre>
<p>
This can be extended to a transducer T that acts as an identity transducer, copying all of its
input to standard out:
<p>
<pre class="code">T = ((ASCII - nl, paste)<b>*</b> (nl, paste out clear))<b>*</b>;</pre>
<p>
In practice transducers recognize much more complex input patterns in source streams that may 
contain unexpected sequences. The ginr compiler allows complex pattern descriptions to be assembled 
from simpler terms but if the resulting automaton is too large the terms can be exported as automata
and stitched together on the Jrte runtime transducer stack, as you would break down an unwieldy Java 
method into smaller methods. And these transducers are resilient to noisy inputs since, with a little help,
they can usually just keep running silently until they stumble upon a sequence that they recognize that 
they can follow back to a synchronization point, usually the start of the innermost containing loop.
<p>
The first and sometimes most painful step in transducer design is to obtain a complete pattern description
that is sufficiently detailed to minimize false positive/negative pattern identification. This can be straightforward 
if there is another formal description for the input format that can be expressed using ginr's operators. 
If only sample inputs are available this pattern must be inferred and developed iteratively. As it is 
developed the pattern description can be factored to maximally expose potential join points -- subpatterns 
(like newline) marking input positions that can be used as recovery points if things go off the rails.
<p>
The pattern description can then be re-purposed as required by extending it with ginr's (,) tuple constructor
to include invokation of 0 or more target effectors, using the shifting operator [..] to bind parameters to 
effectors where required. The result, if subsequential (single-valued -- no branching in the effector
semiring), will be a transducer that must be hardened against domain errors (inputs with no transition
defined). This can be done in a formulaic way in ginr, an example is developed below. 
<p>
One of the main benefits of using ginr to develop transducers is that it allows them to be queried:
<ul>
<li>Does transducer T recognize pattern X?
<li>Does the range of effector sequences in T(X) satisfy all constraints defined on the effector semiring?
</ul>
So it is possible to express in ginr assertions about the correctness of a transducer. These can be 
developed and tested before compiling the ginr transducer into a Jrte gearbox. And it is a very good thing
to do, especially in view of the security unknowns presented by a novel computing environment. In the Jrte 
runtime transduction targets are reshaped by the action of their effectors as selected. Input that has 
been tailored to drive the target into an invalid state may expose vulnerabilities in the host
environment. By designing transducer specifications in the semiring algebra, proofs 
of their correctness can be expressed in terms of constraints on input structure accepted and on sequences
of effectors invoked in the image of the effective domain. Design in the semiring algebra requires no 
special skills or knowledge that would intimidate anyone who had successfully completed a 2nd year 
undergraduate course in algebra.
<p>
Moreover, ginr allows transducer designs to be edited algebraically to eliminate unwanted terms or to 
inject additional terms. Jrte exploits this to harden transducers to accept domain errors and recover
at a synchronization point and to define lookahead transducers that classify upstream input and dispatch
appropriate transducers to control the flow of the transduction process.
<p>
Jrte's close association with ginr has another benefit. By the time they are packaged into a gearbox for 
runtime use, Jrte transducers are maximally compressed and know only about a handful of small sets of 
ordinal numbers:
<ul>
<li>I<sub>n<sub>I</sub></sub> input equivalence ordinals 0..I<sub>n<sub>I</sub>-1</sub>
<li>S<sub>n<sub>S</sub></sub> state equivalence ordinals 0..S<sub>n<sub>S</sub>-1</sub>
<li>E<sub>n<sub>E</sub></sub> target effector ordinals 0..E<sub>n<sub>E</sub>-1</sub>
<li>P<sub>E<sub>m</sub></sub> effector parameter ordinals for each effector ordinal E<sub>m</sub> (m&lt;E<sub>n<sub>E</sub>)
</ul>
All the rest -- characters, encodings, effector actions -- is just local color. Jrte's base transduction target 
offers a simple set of effectors that support awk/perl/sed types of operation on large data sets and may be 
useful as a stand-alone tool. In those settings, all that is required is to define transducers for data of
interest and run the Jrte gearbox compiler to package them into a gearbox. The Jrte runtime can then be used to
transduce data from standard input or from a series of files. In more specialized settings, custom targets may 
be developed to present additional effectors to the transduction, and transducers can be produced to drive these 
effectors in the Jrte runtime. 
<h2>A Brief Tutorial Introduction to ginr+Jrte</h2>
The ginr compiler was first developed by Dr J Howard Johnson and the University of Waterloo, primarily
as a research tool. It was subsequently applied in diverse contexts, including a phonetic mapping and
transduction, in one left-right pass, of the entire corpus of the Oxford English Dictionary from a 
proprietary format to SGML. It is essentially a library for computing automata wrapped in an elementary 
parser that makes operations on automata accessible as an interpreter or compiler for extended regular 
expressions. It allows multi-tape automata to be defined in algebraic (semiring) terms that can manipulated 
to produce subsequential (unabiguous) transducers. 
<p>
Jrte documentation sometimes uses semiring and tape interchangeably; for ginr automaton T the set of  
tape n symbols T<sub>n</sub> = ((T$n):alph) is a semiring with catenation and (^) alternation subsuming all 
regular sets over T<sub>n</sub>*. A summary of the operations supported by ginr can be seen <a href="{@docRoot}/resources/ginr.html">
here</a>. Please refer to the <a href="https://code.google.com/archive/p/ginr/downloads">ginr</a>
downloads page for full ginr documentation.
<p>
Jrte relies on ginr to produce subsequential automata, each automaton T having 3 tapes (semirings):
<ul>
<li> an input tape recognizing some subset of the semiring T<sub>0</sub><b>*</b> of input ordinals 
<li> an effector tape defining some subset of the semiring T<sub>1</sub><b>*</b> on target effector ordinals
<li> a parameter tape T<sub>2</sub> carrying parameter ordinals bound to effectors (like closures)
</ul>
<p>
For recognized input sequences these transducers will drive the target effectors to transform the
target in some manner as determined completely by the input sequences and effector semantics. And 
since all of the control structures that shape the transduction are embedded in the input pattern,
so the scope and complexity of target effectors is minimized -- an effector is a function that 
receives a single input symbol and incorporates it into the target in some manner. So effector
semantics are generally very concise and limited in scope. 
<p>
The fundamental Jrte runtime element is a transduction, which is presented in Java as the 
{@link com.characterforming.jrte.ITransduction} interface. A transduction binds an 
{@link com.characterforming.jrte.IInput} stack, transducer stack, and an {@link com.characterforming.jrte.ITarget} 
instance. When the run() method is called the transduction will read input ordinals from the top of the
input stack and invoke target effectors as directed by the transducer on the top of the transducer stack for each input
 until one of the following conditions is satisfied:
<ol>
<li>the input stack is empty
<li>the transducer stack is empty
<li>an effector returns RTE_PAUSE
<li>an exception is thrown
</ol>
As long as the input and transducer stacks are not empty it may be possible
to call the run() method again after it returns if, for example, the pause
effector caused the run() method to return until more input becomes available. 
Or the run() method might throw a DomainErrorException (input ordinal not recognized 
in current state) and you want to may want persevere after driving the input to a recognizable 
location. In practice, the latter case seldom occurs because transducers can
be hardened to handle domain errors similarly, without excepting. 
<p>
For text-oriented transductions input symbols A include Unicode ordinal values up to a 
declared maximal Unicode ordinal M and signals (Java char[N], N>1) S represented as Unicode ordinal
values >M. Signals include base control signals nul (nothing), nil (something), eol (end of line), 
and eos (end of stream), and counters (end of countdown). Specialized targets can select the maximal 
Unicode character ordinal and define additional signals as required.
<p>
Domain errors are handled by emitting a
nul signal, giving the transduction an opportunity to handle it with an
explicit transition on nul. Usually the error is handled by transitioning to 
a state that finds the next synchronization point, eg end of line. If a domain 
error occurs on a nul signal, a {@link com.characterforming.jrte.DomainErrorException} is 
thrown. For most transducers, domain errors can be avoided entirely by transducing 
the transducer. For example, with line-oriented text, all possible interleavings
of domain errors in the input can be modeled by replacing each non-nl input (x)
with (x|nul) in the original transducer. The resulting transducer can then 
be pruned to produce a transducer that accepts ((any - nl)<b>*</b> nl)<b>*</b>,
switching on nul input to a free running pattern that involves no effectors but seeks 
to synchronize with the input stream at the beginning of the innermost containing loop. 
For simple line-oriented input this can be effected by adding a term after receiving nul 
that consumes all input until newline. 
<p>
IInput.get() will return the eos signal whenever it is called after the
last input ordinal is returned from the input stack. Transducers can explicitly handle
this by including a transition on eos. If eos is not explicitly handled the transduction
will simply stop and ITransduction.run() will return ITransduction.END, no domain error 
will be thrown in that case.
<h3>Transduction Effectors</h3>
The Jrte implementation of the ITransduction interface expresses built-in effectors to 
control the transducer and input stacks, copy input characters, manipulate named values 
from copied from input sequences, and manage countdown counters.
<table border="1" width="100%" cellpadding="3" cellspacing="0" summary="">
<tr bgcolor="#CCCCFF" class="TableHeadingColor">
<th align="left"><b>Transduction Effector</b></th>
<th align="left"><b>Effect on Transduction Target</b></th>
</tr>
<tr>
<td><b>0</b></td>
<td>Signal an undefined transition (equivalent to in[`!nul`])</td>
</tr>
<tr>
<td><b>1</b></td>
<td>Does nothing</td>
</tr>
<tr>
<td><b>start[`@transducer`]</b></td>
<td>Push a named transducer onto the transducer stack</td>
</tr>
<tr>
<td><b>stop</b></td>
<td>Stop the current transducer and pop the transducer stack</td>
</tr>
<tr>
<td><b>shift[`@transducer`]</b></td>
<td>Replace current transducer on top of transducer stack with a named
transducer</td>
</tr>
<tr>
<td><b>in[(`!signal`|`~name`|`text`)+]</b></td>
<td>Push a sequence of mixed text, named values, and signal ordinals onto the
input stack</td>
</tr>
<tr>
<td><b>out[(`!signal`|`~name`|`text`)+]</b></td>
<td>Write a sequence of mixed text, named values, and signal ordinals to
System.out</td>
</tr>
<tr>
<td><b>mark</b></td>
<td>Mark a position in the current input</td>
</tr>
<tr>
<td><b>reset</b></td>
<td>Resets the input to the last mark</td>
</tr>
<tr>
<td><b>end</b></td>
<td>Pops the input stack</td>
</tr>
<tr>
<td><b>select</b></td>
<td>Select the anonymous value as current selection</td>
</tr>
<tr>
<td><b>select[`~name`]</b></td>
<td>Select a named value as current selection</td>
</tr>
<tr>
<td><b>paste</b></td>
<td>Extend the current selection by appending the current input character</td>
</tr>
<tr>
<td><b>paste[`text`]</b></td>
<td>Extend the current selection by appending text</td>
</tr>
<tr>
<td><b>copy[`~name`]</b></td>
<td>Extend the current selection by appending a named value</td>
</tr>
<tr>
<td><b>cut[`~name`]</b></td>
<td>Extend the current selection by appending a named value and clear the named value</td>
</tr>
<tr>
<td><b>clear</b></td>
<td>Clear the current selection</td>
</tr>
<tr>
<td><b>clear[`~name`]</b></td>
<td>Clear the named value</td>
</tr>
<tr>
<td><b>clear[`~<b>*</b>`]</b></td>
<td>Clear all named values and the anonymous value</td>
</tr>
<tr>
<td><b>save[`~name`+]</b></td>
<td>Push a set of named values onto the transducer stack before starting a new
transducer, to be restored when new transducer stops</td>
</tr>
<td><b>restore[`~name`+]</b></td>
<td>Restore a set of named values from the transducer stack after return from
a called transducer</td>
</tr>
<tr>
<td><b>counter[`!signal` `digit+`]</b></td>
<td>Set up a counter signal and initial counter value</td> 
</tr>
<tr>
<td><b>count</b></td>
<td>Decrement the counter and push `!signal` onto the input stack if result is 0</td>
</tr>
</table>
<p>
These effectors are expressed by the base Jrte transduction class. Any 
collection of ginr transducers that require only these built-in effectors can be compiled 
into a gearbox by specifying {@link com.characterforming.jrte.BaseTarget}
as gearbox target class. Specialized {@link com.characterforming.jrte.ITarget}
implementations can express additional effectors for domain-specific
transduction capabilities in their {@link com.characterforming.jrte.ITarget#bind(ITransduction)}
methods. The Jrte gearbox compiler will then bind the new effectors names to the
respective names used in any ginr automata compiled for the gearbox/target. 
<h4>Transduction Control Effectors</h4> The inclusion of a transducer call stack
allows large transducers to be decomposed into smaller transducers, with 
concomitant reduction of RAM footprint. A new transducer can be pushed 
onto the transducer stack using the <b>start[..]</b> effector. The new 
transducer will then run until it invokes the the <b>stop</b> effector and 
pop the transducer stack. The <b>shift[..]</b> effector replaces the transducer 
on the top of the call stack, allowing transducers to be chained (concatenated). 
<h4>Input and Output Effectors</h4> Transductions are driven by a stack/queue
of {@link com.characterforming.jrte.IInput} instances and process each input is a 
single pass. Or two, if using lookahead to verify input before committing to 
transduction. 
<p>
The <b>in[..]</b> effector pushes signals, named values, or text onto the input stack as
a single IInput stream for immediate processing. This is mainly used to raise
out-of-band signals during text processing. This allows, for example, 
transducers to be called like functions using the <b>start</b> effector and 
return values using <b>in[..]</b> that the calling transducer can use to 
discriminate ambiguous cases. The <b>out[..]</b> effector prints signals, 
named values, or text to System.out. It is mainly used for debugging/verifying 
transducers. In practice, specialized target classes will supplement this with analogous 
effectors that decorate captured values with other formats -- XML, JSON, CSV, SQL, POJO, ...
<p>
To force a return from the {@link com.characterforming.jrte.ITransduction#run()} 
method, use the <b>pause</b> effector. This normally done in response to empty input
stack in contexts where the transduction is being driven by a remote source that is 
expected to resume output at some future time. Pause has no effect on the 
transducer or input stacks and the transduction can be resumed when new input 
arrives. 
<p>
The <b>end</b> effector can be used to pop the input stack before end 
of current input.
<h4>Compositing Effectors</h4> Each transduction has a set of named values,
including an anonymous value that can be used as a scratch pad for copying
input. At any time, any value can be selected using the <b>select[..]</b>
effector, providing the name of the value to be selected as a parameter. The 
selected value is called the <i>selection</i>. The anonymous value is preselected 
in the {@link com.characterforming.jrte.ITransduction#start(String)} method and 
can be reselected using the <b>select</b> effector with no parameter. It can be 
explicitly referenced as an effector parameter using `~`. 
<p>
The <b>paste</b> effector with no parameter extends the selection with the 
current input character. The parameterized form <b>paste[..]</b> extends the selection 
with the specified parameter text. The <b>clear</b> effector with no parameter
clears the anonymous value, and the <b>clear[..]</b> effector clears the specified 
named value. To clear all named values, including the anonymous value and the 
selection, use <b>clear[`~<b>*</b>`]</b>. The <b>cut[..]</b> and <b>copy[..]</b> effectors 
extend the selection by appending a specified named value. The named value
is cleared by <b>cut[..]</b> and is not cleared by <b>copy[..]</b>.
<p>
The collection of named values is global to the transduction and are not
automatically pushed with the transducer stack. If the calling transducer is
required to save values that might otherwise be overwritten by the called
transducer, the caller can use the <b>save[..]</b> effector to push a subset of
named values onto the value stack before started the called transducer. The
saved values can be restored using the <b>restore[..]</b> effector when the
called transducer returns.
<h4>Counter Effectors</h4> Each transducer is provided with a single counter.
This is set up by the <b>counter[..]</b> effector with countdown value and a
counter signal. The counter signal is raised when the <b>count</b> effector
decrements the countdown to zero. This may be extended at some point to 
include named counters as well as counters that count up.
<h4>Application Effectors</h4> Application-defined ITarget classes can
implement additional {@link com.characterforming.jrte.IEffector} classes to assemble domain objects
in the application target class. When the application target is bound to 
a transduction with {@link com.characterforming.jrte.Jrte#transduction(ITarget)}, it can control 
the transduction and access transduction products (eg, named values) 
through the {@link com.characterforming.jrte.ITransduction} interface. The gearbox compiler will 
discover all of the base and application effectors during the target
binding process.
<h2>Time is money. RAM is Cheap</h2>
<p>
The transducers that Jrte produces from ginr automata are state- and transition-minimized 
DFAs. These objects are maximally compact, and  while it is of
course possible to produce very large transducers, these can usually be decomposed into smaller
transducers that can be stitched together on the Jrte runtime transducer stack, just as one
would decompose a large Java program into smaller methods to capture common factors and reduce
program footprint in RAM compared to the fully inlined program. 
<p>
DFAs express complexity in the spatial domain (RAM) and are strictly linear in the temporal 
domain. This is a good thing because, as the chapter title says, time is money and RAM is cheap. 
It is easy to see why -- every transduction has at its core a loop that executes, exactly once for
each input symbol:
<p>
<pre class="code">
target.effect(transducer.step(input.get()))
</pre>
<p>
That is, get the next input, execute a state transition and return an effector sequence, invoke
effectors sequentially. The complexity of a transducer, as measured by the number of transitions
in the fully minimized automaton, will increase with the entropy of its input domain. 
The transducer's throughput, measured by number of transitions triggered per unit of time, will be 
roughly constant regardless of the length or complexity of the input if all of the target effectors
have constant cost. Non-linear performance characteristics will emerge if one or more effectors 
have costs that interact with length or other properties of the input (see the Fibonacci 
transducer in the next section for an example of this). 
<p>
I once worked for a firm that dedicated server blades exclusively to scanning incoming
log files and extracting  information using Java regex. I think they would have been pleased to 
learn that they could double or triple their throughput per blade at the cost of a few 
gigabytes of RAM.
<p>
The chart below shows BaseTarget running the 3 tutorial transducers that extract
IP tables log information from a Linux kernel log versus an equivalent Java regex on a 20 MB 
source stream, in RAM. Jrte transducers and the regex expression were compiled outside the 
timing loop.
<p>
Input looked like this:
<p>
<pre class="code">...
May 15 20:50:49 kb-ubuntu kernel: [48111.207020] ABORTED IN=eth0 OUT= MAC=00:0c:76:7e:c3:6a:00:25:9c:50:8a:c5:08:00 SRC=209.92.63.245 DST=168.144.100.192 LEN=40 TOS=0x00 PREC=0x00 TTL=50 ID=0 DF PROTO=TCP SPT=443 DPT=2864 SEQ=261504615 ACK=0 WINDOW=0 RES=0x00 RST URGP=0 
May 15 20:50:49 kb-ubuntu kernel: [48111.239889] LIMITED IN=eth0 OUT= MAC=00:0c:76:7e:c3:6a:00:25:9c:50:8a:c5:08:00 SRC=209.92.63.245 DST=168.144.100.192 LEN=40 TOS=0x00 PREC=0x00 TTL=50 ID=0 DF PROTO=TCP SPT=443 DPT=2865 WINDOW=0 RES=0x00 RST URGP=0 
May 15 21:18:20 kb-ubuntu kernel: [49762.580044] DROPPED IN= OUT=eth0 SRC=144.100.192.168 DST=166.14.77.142 LEN=40 TOS=0x00 PREC=0x00 TTL=64 ID=58654 DF PROTO=TCP SPT=5599 DPT=80 SEQ=3700374964 ACK=2125211911 WINDOW=338 RES=0x00 ACK PSH FIN URGP=0 
May 15 21:18:21 kb-ubuntu kernel: Kernel logging (proc) stopped.
May 16 07:01:49 kb-ubuntu kernel: imklog 4.2.0, log source = /proc/kmsg started.
...</pre>
<p>Java regex looked like this:
<p>
<pre class="code">
([JFMASOND][a-z]+ [0-9]+ ([0-9]+:)+[0-9]+) ([-A-Za-z_0-9]<b>*</b>) kernel: \\[[ ]<b>*</b>[0-9]+\\.[0-9]+\\] (DROPPED|ABORTED|LIMITED) IN=([-A-Za-z_0-9]<b>*</b>) OUT=([-A-Za-z_0-9]<b>*</b>) (MAC=([A-Fa-f:0-9]<b>*</b>) )?SRC=([.0-9]<b>*</b>) DST=([.0-9]<b>*</b>).<b>*</b> PROTO=([A-Z0-9]<b>*</b>)(.<b>*</b> SPT=([0-9]<b>*</b>) DPT=([0-9]<b>*</b>))?.<b>*</b>\n
</pre>
Three different ways to transduce this input using ginr and Jrte are shown <a href="{@docRoot}/resources/kern.html">here</a>.
Definitions for the simple terms of these transducers are expressed in a <a href="{@docRoot}/resources/prologue.html">prologue</a>
that is compiled first so that these terms are available to all transducers.
<h3>LinuxKernel</h3>
The LinuxKernel transducer is hardened against domain errors and will accept ((any - nl)<b>*</b> nl)<b>*</b>, modulo signal 
inputs. It is the most performant of the Jrte transducers presented here, but it invokes mutator effectors (select, paste) 
on the target while scanning the prefix of each line. In this case the prefix effect on the target is reversed if a nul 
is raised in response to a domain error by invoking the clear[`~<b>*</b>`] effector after consuming the remainder of the 
line without effect. This would not be effective if incomplete effector actions left the target in an irreversibly 
inconsistent state.
<p>
This example shows how to harden a transducer against domain errors. The general strategy is to inject nul into the transducer's 
domain wherever an input is accepted, flatten the resulting transducer onto a single tape, transduce the result to snip the 
trailing suffix after the first nul in every sequence containing nul, transduce the result back onto 3 tapes, and append to
each nul-truncated sequence a transducer that consumes input without effect until it recognizes a synchronization point, 
typically the start of the innermost containing loop.
<p>
The technique of transducing transducers by flattening, editing with another transducer, and transducing the result back
onto the original tapes has applications in other contexts as well. This is possible whenever the tape alphabets are 
disjoint and, if necessary, the tape alphabets can always be mapped into disjoint sets in the original transducer and 
restored when transducing the flattened and edited transducer back to its original shape. 
<h3>LinuxKernelStrict</h3>
This transducer takes the high road and looks ahead, after marking an anchor in the input stream, to verify that it has
a recognizable match and identify the matching pattern. Lookahead transducers of the type shown here are composed from the 
union of input patterns that could appear in the input in specific contexts. The input patterns that are included as 
possible alternatives are the domain patterns of transducers that are designed for those contexts. If the lookahead 
recognizes one of these patterns it resets input to the anchor, starts the matching transducer, and resumes when the
selected transducer ends. If no match is recognizable, the lookahead transducer consumes input without effect until 
the next synchronization point (eg, end of line). 
<p>
This approach is preferred if there is any chance of the transducer forcing the target into an irreversible and
inconsistent state. This is the safest and least performant of the 3 Jrte alternatives presented, but its 
throughput is still >1.5X higher than Java regex.
<p>
This example shows how to use lookahead to recognize and classify patterns in the incoming input. This can also be used to
resolve ambiguous cases where choice of transduction path depends on upstream information. 
<h3>LinuxKernelLoose</h3>
This transducer presupposes that if the (header tag) prefix of (line) can be matched on a lookahead search, the rest of 
the line will match without domain errors. This strategy will work only insofar as the transducer input pattern 
describes completely the range of the input source. If the prefix matches, any domain error occurring in the 
unverified (capture) suffix of (line) will result in a DomainErrorException, leaving the transduction and 
target in incomplete states.
<h3>Results</h3>
Because this was a performance benchmark, no fields were
printed. On each run Jrte processed the entire file in one call to {@link com.characterforming.jrte.ITransduction#run()},
invoking the disabled out[..] effector for each matched line; regex ran a series of Matcher.find() calls, 
each returning without output the next matched line. Subsequent runs with output enabled verified that the matches were
correct in all cases but regex. Jrte and regex both identified the same lines as matching (about 60% of lines matched) and captured
the same fields from each matched line. Java regex had trouble with the DPT and SPT tag match group and printed null for these fields
where Jrte captured the respective port number. This occurred for more than half of the lines matched by regex. There were no 
exceptions thrown, with or without output enabled.
<hr>
<img src="resources/LinuxKernelLog.png"/>
<hr>
<h2>Some Fun with Numbers</h2>
Computer science wonks love this stuff. Here's some:
<pre class="code">
$ for n in '' 0 00 000 0000 00000 000000 0000000 00000000 000000000; do echo $n | jrte Fibonacci; done

0
0
00
000
00000
00000000
0000000000000
000000000000000000000
0000000000000000000000000000000000
</pre>
<p>
That was easy...
<pre class="code">
Fibonacci = (
   <i># ~r, ~q, ~p are sequences of 0s preset to empty string 0<sup>0</sup> (0 in <b>N</b>)</i>
   (
      <i># F<sub>1</sub>: ~r <- 0<sup>1</sup> (1 in <b>N</b>)</i>
      ('0', select[`~r`] paste)
      <i># fib(n>1): cycle (~p) <- (~q) <- (~r) <- (~p)(~q), (~p) <- 0<sup>0</sup></i>
      ('0', select[`~p`] cut[`~q`] select[`~q`] cut[`~r`] select[`~r`] cut[`~p`] copy[`~q`])<b>*</b>
   )<b>?</b>
   <i># (~r) holds the result, so append nl and print 0<sup>F<sub>n</sub></sup>nl</i>
   (nl, select[`~r`] paste out[`~r`] stop)
);

(Fibonacci$(0,1 2)):prsseq;

(START)  0 [ select[~r] paste ]                                                  1
(START) \n [ select[~r] paste out[~r] stop ]                                     (FINAL)
1        0 [ select[~p] cut[~q] select[~q] cut[~r] select[~r] cut[~p] copy[~q] ] 1
1       \n [ select[~r] paste out[~r] stop ]                                     (FINAL)
</pre>
<p>
Easy because Fibonacci is a simple arithmetic progression, so we can use the morphism (<b>N</b>, +) &map; ({0}, catenation)
to map into Jrte's domain. Jrte can also compute Ackerman's function A(X,Y) for X in {0,1,2} because these values 
represent a progression of arithmetic operations -- addition (X=0), multiplication (X=1), exponentiation (X=2). It 
gets strange in the fourth and higher dimensions, but Jrte may be able to compute these, theoretically, using 
the transducer stack. An exercise for a rainy afternoon. RAM is cheap.
<h3>Some Serious Numbers</h3>
Arithmetic is not exactly a key strength for Jrte, since it can only work with unary numbers (if you balked
at counting in the example above, the inputs were the numbers 0-9 and the outputs were (0,1,1,2,3,5,8,13,21,34).
But there are strong connections between formal finite automata and number theory that can be exploited. For 
example, it is easy to produce a generating function for any automaton T, given an equivalence relation E that 
maps the alphabet A of T to formal variables and a weighting function w:A&map;<b>N</b>.
<ol>
<li>from T generate an equivalent regular expression R that uses only semiring operations catenation, alternation, Kleene-<b>*</b>
<li>replace each domain symbol a in R with x<sup>w(a)</sup>, where x is the variable assigned to the equivalence class E<sub>a</sub>
<li>iteratively replace operators and terms in R: catenation&map;multiplication; alternation&map;addition; T<b>*</b>&map;1/(1-T); T<b>?</b>&map;1+T
<li>simplify and expand the result as a power series S(x) (convergent for 0&le;x&lt;1) 
</ol>
In the resulting series S(x), the coefficient of x<sup>n</sup> (denoted [x<sup>n</sup>]S) is the number of strings of 
weight n in the domain of the transducer. For example, the input pattern of any Jrte transducer has a univariate 
length generating function L(x). This obtained by mapping all input symbols to the variable x with weighting function 
l(a) = 1 for a in {0,nl}. The length generating function for the input domain 0<sup><b>*</b></sup>nl of Fibonacci is 
<pre class="code">L(x) = (1 + x(1 / (1 - x)))x = x / (1 - x) = &Sigma;<sub>n&ge;0</sub>(x<sup>n+1</sup>)</pre>
and [x<sup>0</sup>]L = 0, [x<sup>n</sup>]L = 1 for n&gt;0, because all inputs to Fibonacci include a nl character. If we
choose a different weighting function z:{0,nl}&map;{0,1} that assigns unit weight to 0 and zero weight to nl, the 
generating function is just <pre class="code">Z(x) = 1 + x(1 / (1 - x))x<sup>0</sup> = 1 / (1 - x) = &Sigma;<sub>n&ge;0</sub>x<sup>n</sup></pre>
and [x<sup>n</sup>]Z = 1 for n&ge;0.
<h3>Seriouser and Seriouser</h3>
This can be extended to include the range of Fibonacci as well, to obtain length-work generating functions that
relate the length of the input to some properties of interest in the effector range, by binding disjoint 
effector-parameter combinations as unitary symbols (as was done above for ginr's printout of the subsequential 
Fibonacci automaton). But there is an interesting wrinkle, one that will give functional programming purists
something to moan about. Recall my assertion that DFAs had linear performance characteristics? In Jrte contexts 
this is only true if all effectors have constant execution time, independent of transduction state or external 
factors; in other words, if they are stateless.
<p>
But the Jrte transduction model admits a stateful target object that may be constantly mutating as it 
assimilates the input symbols conveyed to its effectors by the active transducer. That is exactly what 
Jrte is designed to enable. Pattern-driven design allows pattern designers to articulate the structure 
of input sources without regard to extension to possible targets, and reduces effort for target designers 
who want to assimilate information from input sources without having to internalize the syntactic representation 
of every source of interest. All of the control logic involved in the transduction of input to target is 
expressed algebraically as a morphism that interleaves the input pattern with an effector pattern to direct 
the transduction process. Taking machine as target and machine instruction set as effector set, the 
transduction computing model inverts the locus of machine control. Instructions are selected by the active 
transducer in patterned response to sequential inputs and no branching instructions of any kind are 
involved. The burden of programming the target is lifted almost entirely from the designer of the 
transduction system as it is reduced to articulating input patterns and binding them to target. 
<p>
The downside is that combinatorial and other types of analyses become more difficult, because algebraic 
transducer descriptions include no information about the semantics of individual effectors. For example, 
it is not apparent in the definition of Fibonacci that the copy/cut[..] effectors have a cost that 
increases with the length of the input. Insider knowledge of the semantics of these operators and of 
the history of the transduction is required to determine appropriate weights for these operators, if the
intention is to produce a multivariate length-work generating function to characterize how the operating
dynamics the transduction change with increasing length of input. 
<p>
So Fibonacci has some nonlinear characteristics and these are opaque to the purely syntactic representation 
of Fibonacci, which is the basis for this sort of analysis. But lets stumble along and see what we can do to
get a handle on these. Say we want to determine the number C<sub>n</sub> of 0s copied into the transduction 
target variables ~p, ~q and ~r in the Fibonacci computation of F<sub>n</sub>. The target variables are preset
to 0<sup>0</sup> and the first 0 input is pasted (not copied) into ~r. Copying is done for n&gt;1 input 0s, 
by copy/cut[..] effectors arranged in a vector within a single transition
<pre class="code">(select[`~p`] cut[`~q`]) (select[`~q`] cut[`~r`]) (select[`~r`] cut[`~p`] copy[`~q`])</pre>
that is triggered once for each of the last m = n-1 0s in the input. I've grouped the terms in the transition
to identify the configurations of interest. For m&gt;1, on the m<sup>th</sup> iteration, ~p receives 
0<sup>F<sub>m-2</sub></sup>, ~q receives 0<sup>F<sub>m-1</sub></sup>, and these values are catenated
to produce 0<sup>F<sub>m</sub></sup> in ~r. These are the configurations to be tracked in our length-work
generating function. Labeling these configurations as p, q, r with unit weight, and labelling inputs 0 and nl
with x with weights 1 and 0, respectively, a generating function for Fibonacci that just counts occurrences of 
these configurations is  
<pre class="code">W(x,p,q,r) = 1 + x(1 / (1 - xpqr))x<sup>0</sup> = 1 + &Sigma;<sub>n&ge;0</sub>x<sup>n+1</sup>p<sup>n</sup>q<sup>n</sup>r<sup>n</sup></pre>
but this tells us little about the volume of copy transferred into the ~p, ~q and ~r values in the transduction 
Fibonacci(0<sup>n</sup>nl). We can inject that information and collapse p, q, r into a single variable y 
that marks the transfer of a single 0 by mapping p, q, r onto y with appropriate length-dependent weights
that sum the number of 0s copied into each of ~p, ~q, ~r on the last n-1 iterations:
<ul>
<li>w(n,p) = 0 for n&le;1 and &Sigma;<sub>1&lt;m&lt;n</sub>F<sub>m-1</sub> for n&gt;1</li>
<li>w(n,q) = 0 for n&le;1 and &Sigma;<sub>1&lt;m&lt;n</sub>F<sub>m</sub> for n&gt;1</li>
<li>w(n,r) = 0 for n&le;1 and &Sigma;<sub>1&lt;m&lt;n</sub>F<sub>m+1</sub> for n&gt;1</li>
</ul>
Then C<sub>n</sub> will be the exponent of the y cofactor of x<sup>n</sup> in the length-work generating function for Fibonacci.
<pre class="code">W<sup>'</sup>(x,y) = 1 + x + &Sigma;<sub>n&ge;1</sub>x<sup>n+1</sup>y<sup>w(n,p) + w(n,q) + w(n,r)</sup>
        = 1 + x + &Sigma;<sub>n&ge;1</sub>x<sup>n+1</sup>y<sup>&Sigma;<sub>1&lt;m&lt;n</sub>F<sub>n-1</sub> + &Sigma;<sub>1&lt;m&lt;n</sub>F<sub>n</sub> + &Sigma;<sub>1&lt;m&lt;n</sub>F<sub>n+1</sub></sup>
        = 1 + x + &Sigma;<sub>n&ge;1</sub>x<sup>n+1</sup>y<sup>&Sigma;<sub>1&lt;m&lt;n</sub>2F<sub>n+1</sub></sup>
        = 1 + x + &Sigma;<sub>n&gt;1</sub>x<sup>n</sup>y<sup>&Sigma;<sub>1&lt;m&lt;n</sub>2F<sub>n</sub></sup>
        = 1 + x + &Sigma;<sub>n&gt;1</sub>x<sup>n</sup>y<sup>2[(F<sub>n+2</sub> - 1) - (F<sub>0</sub> + F<sub>1</sub>)]</sup>
        = 1 + x + &Sigma;<sub>n&gt;1</sub>x<sup>n</sup>y<sup>2F<sub>n+2</sub> - 4</sup></pre>
So C<sub>0</sub> = C<sub>1</sub> = 0 and C<sub>n</sub> = 2F<sub>n+2</sub> - 4 for n&gt;1. And that's a good thing to know. 
Once the initial 0 has been latched into ~r after the first 0 is received, thing multiplies 
like rabbits as the transducer iterates over any remaining inputs. This isn't surprising, because Dr Fibonacci
was studying rabbit populations when he came up with this sequence. In his model, in the n<sup>th</sup> generation produces 
F<sub>n</sub> new rabbits to join F<sub>n-2</sub> + F<sub>n-1</sub> = F<sub>n</sub> survivors from previous generations while
C<sub>n</sub> - 2F<sub>n</sub> = F<sub>n+1</sub> - 4 ancestral rabbits drink beer in Valhalla. Such is life. In 
the Fibonacci transducer the cut[..] effector operates as a culling factor, leaving just 3 generations of 0s in the target
after each iteration. 
<p>
This simple example illustrates how important insights into the dynamics of transduction systems can gained 
when there is a clear separation of concerns between syntax and semantics. The same analytic approach used here 
can be applied to more complex transducers, such as the kernel log variants presented in the regex runoff above. 
And while the algebra may seem daunting at first, these techniques have been used for decades and the algebraic algorithms
involved are well known. Modern symbolic algebra engines like Maxima (previously known as Macsyma) are 
available to ease the pain, and if Dr Watson could bone up on his algebra and combinatorics he might find 
a cure. 
</body>
</html>