#May 15 07:58:52 kb-ubuntu kernel: [ 1794.599801] DROPPED IN=eth0 OUT= MAC=01:00:5e:00:00:fb:00:13:20:c0:36:32:08:00 SRC=192.168.144.101 DST=224.0.0.251 LEN=32 TOS=0x00 PREC=0x00 TTL=1 ID=8596 OPT (94040000) PROTO=2 

### LinuxKernel
# This will extract up to 10 field values from iptables log messages in a Linux kernel log 
# containing mixed messages from various sources. Input is reduced in a single pass without
# lookahead, fields extracted from iptables messages are reordered for output to stdout. 
###

timestamp = upper lower+ space digit digit? space (digit digit ':')+ digit digit;
value = {alpha, digit, punct}*;

header = (
	(timestamp @@ PasteAny)
	(space, select[`~hostname`])
	(value @@ PasteAny) 
	(space 'kernel: [' space* digit+ '.' digit+ space* ']')
);

field = (
	(
			('IN=', select[`~in`])
		|	('OUT=', select[`~out`])
		|	('MAC=', select[`~macaddress`])
		|	('SRC=', select[`~srcip`])
		|	('DST=', select[`~dstip`])
		|	('SPT=', select[`~srcport`])
		|	('DPT=', select[`~dstport`]) 
		|	('PROTO=', select[`~protocol`])
	)
	(value @@ PasteAny)
);

tag = (space, select[`~tag`]) (('DROPPED' | 'LIMITED' | 'ABORTED') @@ PasteAny);
data = (space (field || value))+ space;
line = header tag data;

a0 = (line$0):alph;
a1 = (line$1):alph;
a2 = (line$2):alph;

# Restrict AnyOrNul to exclude nul injection for nl
NotNlOrNul = AnyOrNul @@ (byte - nl);

null = (
	(
			((NotNlOrNul* @ line)$(0 1 2))
		@	((a0$(0,0))* (a1$(0,,0))* (a2$(0,,,0))*)*
			(nul$(0,0)) (nul* a0* a1* a2*)* 
	)
	(byte - nl)*
);

store = out[
	`~timestamp` '|'
	`~hostname` '|'
	`~tag` '|'
	`~in` '|'
	`~out` '|'
	`~macaddress` '|'
	`~srcip` '|'
	`~dstip` '|'
	`~protocol` '|'
	`~srcport` '|'
	`~dstport` `\n`
];

continue = clear[`~*`] select[`~timestamp`];

LinuxKernel = (
	(nil, continue) 
	(
		line (nl, store continue)
	|	null (nl, continue)
	)*
):dfamin;

### LinuxKernelStrict 
# This will mark input at start of line and look ahead using the input patterns of 3 transducers
# describing lines of interest up to and including nl. If any of these patterns match the entire 
# line, the input is reset to the mark and the matching transducer is started to consume the line.
# If nul is signaled in the matching pass it will be caught and the entire line will be consumed 
# without effect.
###

LinuxKernelDropped = (
	header (space, select[`~tag`]) ('DROPPED' @@ PasteAny) data (nl, store in[`!nil`] stop)
):dfamin;

LinuxKernelLimited = (
	header (space, select[`~tag`]) ('LIMITED' @@ PasteAny) data (nl, store in[`!nil`] stop)
):dfamin;

LinuxKernelAborted = (
	header (space, select[`~tag`]) ('ABORTED' @@ PasteAny) data (nl, store in[`!nil`] stop)
):dfamin;

dropped = LinuxKernelDropped$0;
limited = LinuxKernelLimited$0;
aborted = LinuxKernelAborted$0;

line = (dropped | limited | aborted) / nl;
null = (line:pref) nul (byte - nl)*;
next = reset continue;

LinuxKernelStrict = (
	(
		(nil, mark)
		(
			(
				(dropped, next start[`@LinuxKernelDropped`])
			|	(limited, next start[`@LinuxKernelLimited`])
			|	(aborted, next start[`@LinuxKernelAborted`])
			)
		| null (nl, in[`!nil`])
		)?
	)*
):dfamin;

### LinuxKernelLoose 
# This will mark and look ahead only far enough to select a capable transducer 
# or skip a line. If the called transducer fails to match after the verified 
# prefix nul will be signaled but not caught and the transduction will throw
# a DomainErrorException.
###

LinuxKernelCapture = (
	LinuxKernelDropped | LinuxKernelLimited | LinuxKernelAborted
):dfamin;

type = (header tag)$0;
null = ((type:pref) - type) nul (byte - nl)*;

LinuxKernelLoose = (
	(
		(nil, mark) 
		(
			(type, next start[`@LinuxKernelCapture`])
		|	null (nl, in[`!nil`])
		)?
	)*
):dfamin;

### LinuxKernelNil
# Recognizer for kernel log
###

LinuxKernelNil = (
	(LinuxKernel$0) (eos, stop)
):dfamin;

LinuxKernelDropped:save `build/patterns/automata/LinuxKernelDropped.dfa`;
LinuxKernelDropped$(0,1 2):prsseq `build/patterns/automata/LinuxKernelDropped.pr`;
LinuxKernelLimited:save `build/patterns/automata/LinuxKernelLimited.dfa`;
LinuxKernelLimited$(0,1 2):prsseq `build/patterns/automata/LinuxKernelLimited.pr`;
LinuxKernelAborted:save `build/patterns/automata/LinuxKernelAborted.dfa`;
LinuxKernelAborted$(0,1 2):prsseq `build/patterns/automata/LinuxKernelAborted.pr`;
LinuxKernelLoose:save `build/patterns/automata/LinuxKernelLoose.dfa`;
LinuxKernelLoose$(0,1 2):prsseq `build/patterns/automata/LinuxKernelLoose.pr`;
LinuxKernelStrict:save `build/patterns/automata/LinuxKernelStrict.dfa`;
LinuxKernelStrict$(0,1 2):prsseq `build/patterns/automata/LinuxKernelStrict.pr`;
LinuxKernelCapture:save `build/patterns/automata/LinuxKernelCapture.dfa`;
LinuxKernelCapture$(0,1 2):prsseq `build/patterns/automata/LinuxKernelCapture.pr`;
LinuxKernelNil:save `build/patterns/automata/LinuxKernelNil.dfa`;
LinuxKernelNil$(0,1 2):prsseq `build/patterns/automata/LinuxKernelNil.pr`;
LinuxKernel:save `build/patterns/automata/LinuxKernel.dfa`;
LinuxKernel$(0,1 2):prsseq `build/patterns/automata/LinuxKernel.pr`;
